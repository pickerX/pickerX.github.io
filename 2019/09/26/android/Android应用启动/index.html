<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Android,framework,">










<meta name="description" content="在讲应用启动之前，我们需要了解两个知识点  Binder IPC机制 Zygote 机制    Binder IPC比较复杂，请移步Binder IPC机制 Zygote？我们知道，Android 是基于 Linux 内核开发的，而在 Linux 中，所有的进程都是直接或者间接地由 init 进程 fork 出来的。Zygote 进程也不例外，它是在系统启动的过程，由 init 进程创建的。 Zy">
<meta name="keywords" content="Android,framework">
<meta property="og:type" content="article">
<meta property="og:title" content="Android应用启动">
<meta property="og:url" content="http://yoursite.com/2019/09/26/android/Android应用启动/index.html">
<meta property="og:site_name" content="Hello,world">
<meta property="og:description" content="在讲应用启动之前，我们需要了解两个知识点  Binder IPC机制 Zygote 机制    Binder IPC比较复杂，请移步Binder IPC机制 Zygote？我们知道，Android 是基于 Linux 内核开发的，而在 Linux 中，所有的进程都是直接或者间接地由 init 进程 fork 出来的。Zygote 进程也不例外，它是在系统启动的过程，由 init 进程创建的。 Zy">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://b-ssl.duitang.com/uploads/blog/201405/03/20140503185212_4A5zW.jpeg">
<meta property="og:updated_time" content="2019-11-23T07:14:10.564Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android应用启动">
<meta name="twitter:description" content="在讲应用启动之前，我们需要了解两个知识点  Binder IPC机制 Zygote 机制    Binder IPC比较复杂，请移步Binder IPC机制 Zygote？我们知道，Android 是基于 Linux 内核开发的，而在 Linux 中，所有的进程都是直接或者间接地由 init 进程 fork 出来的。Zygote 进程也不例外，它是在系统启动的过程，由 init 进程创建的。 Zy">
<meta name="twitter:image" content="http://b-ssl.duitang.com/uploads/blog/201405/03/20140503185212_4A5zW.jpeg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/26/android/Android应用启动/">





  <title>Android应用启动 | Hello,world</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hello,world</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/26/android/Android应用启动/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pickerX">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello,world">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android应用启动</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-26T14:03:32+08:00">
                2019-09-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope="" itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="http://b-ssl.duitang.com/uploads/blog/201405/03/20140503185212_4A5zW.jpeg" rel="gallery_ck9qucjcj000jgwxzmgfqlp1q" itemscope="" itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="http://b-ssl.duitang.com/uploads/blog/201405/03/20140503185212_4A5zW.jpeg" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        <p>在讲应用启动之前，我们需要了解两个知识点</p>
<ul>
<li>Binder IPC机制</li>
<li>Zygote 机制  </li>
</ul>
<p>Binder IPC比较复杂，请移步<a href="">Binder IPC机制</a></p>
<h2 id="Zygote？"><a href="#Zygote？" class="headerlink" title="Zygote？"></a>Zygote？</h2><p>我们知道，Android 是基于 Linux 内核开发的，而在 Linux 中，所有的进程都是直接或者间接地由 init 进程 fork 出来的。Zygote 进程也不例外，它是在系统启动的过程，由 init 进程创建的。</p>
<h3 id="Zygote-的运行"><a href="#Zygote-的运行" class="headerlink" title="Zygote 的运行"></a>Zygote 的运行</h3><p>做过手机系统开发的大佬都知道，init 进程代码在系统启动脚本 system/core/rootdir/init.rc 文件中。 截取一部分代码，可以发现，<br>是通过运行 service zygote 命令来创建 zygote </p>
<pre><code>service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server
class main
socket zygote stream 660 root system
onrestart write /sys/android_power/request_state wake
onrestart write /sys/power/state on
...
</code></pre><h3 id="初始化-Zygote"><a href="#初始化-Zygote" class="headerlink" title="初始化 Zygote"></a>初始化 Zygote</h3><p>执行命令后，最终会调用 Zygote 相关的 Java 代码。Zygote 进程的初始化在 ZygoteInit 这个类中的 main 方法</p>
<pre><code>public static void main(String argv[]) {
    // zygote 进程的 socketServer 
    ZygoteServer zygoteServer = new ZygoteServer();
    ZygoteHooks.startZygoteNoThreadCreation();

    ...

    final Runnable caller;
    try {

        boolean startSystemServer = false;
        String socketName = &quot;zygote&quot;;
        String abiList = null;
        boolean enableLazyPreload = false;

        // 为 zygote 命令连接(ZygoteConnection)注册一个 server socket
        // 内部实现类 LocalServerSocket Os.listen 开始一个阻塞监听 socket 连接
        zygoteServer.registerServerSocket(socketName);
        ...

        if (startSystemServer) {
            // 创建系统进程
            Runnable r = forkSystemServer(abiList, socketName, zygoteServer);
            if (r != null) {
                r.run();
                return;
            }
        }

        // SocketServer 阻塞监听连接
        caller = zygoteServer.runSelectLoop(abiList);
    } catch (Throwable ex) {
        Log.e(TAG, &quot;System zygote died with exception&quot;, ex);
        throw ex;
    } finally {
        zygoteServer.closeServerSocket();
    }

    // We&apos;re in the child process and have exited the select loop. Proceed to execute the
    // command.
    if (caller != null) {
        caller.run();
    }
}
</code></pre><h3 id="ZygoteServer-轮询连接"><a href="#ZygoteServer-轮询连接" class="headerlink" title="ZygoteServer 轮询连接"></a>ZygoteServer 轮询连接</h3><p>runSelectLoop 方法，来看看关键的代码，while(true) 死循环，轮询操作，接收一个新的连接，读取命令</p>
<pre><code>Runnable runSelectLoop(String abiList) {
    ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;();
    ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();

    fds.add(mServerSocket.getFileDescriptor());
    peers.add(null);
    // 轮训 FileDescriptor，peers
    while (true) {
        StructPollfd[] pollFds = new StructPollfd[fds.size()];
        ...
        try {
            if (i == 0) {
                // 接收一个新的连接，保存到集合
                ZygoteConnection newPeer = acceptCommandPeer(abiList);
                peers.add(newPeer);
                fds.add(newPeer.getFileDesciptor());
            } else {
                // 下一次 while轮训时， 拿到 socket 连接
                ZygoteConnection connection = peers.get(i);
                // 处理命令
                final Runnable command = connection.processOneCommand(this);
                ...
            }
        } catch (Exception e) {
            ...
        }
    }
}
</code></pre><p>使用过 socket 的大佬应该很熟悉，</p>
<ul>
<li>ZygoteServer 相当于 SocketServer 服务端包装类</li>
<li>ZygoteConnection 表示一个远端 Socket 连接</li>
</ul>
<h3 id="ZygoteConnection-处理命令"><a href="#ZygoteConnection-处理命令" class="headerlink" title="ZygoteConnection 处理命令"></a>ZygoteConnection 处理命令</h3><p>我们看看 ZygoteConnection 是怎么处理命令的，</p>
<pre><code>Runnable processOneCommand(ZygoteServer zygoteServer) {
    String args[];
    Arguments parsedArgs = null;
    FileDescriptor[] descriptors;

    ...
    // 实际创建进程的地方还是回到了 Zygote 类中
    pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,
            parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,
            parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.instructionSet,
            parsedArgs.appDataDir);

    // 创建进程后的处理，异常处理，关闭连接等
    ...
}
</code></pre><p>回到 Zygote forkAndSpecialize 中，</p>
<pre><code> public static int forkAndSpecialize(int uid, int gid, int[] gids, int debugFlags,
      int[][] rlimits, int mountExternal, String seInfo, String niceName, int[] fdsToClose,
      int[] fdsToIgnore, String instructionSet, String appDataDir) {
    // ZygoteHooks
    VM_HOOKS.preFork();
    // Resets nice priority for zygote process.
    resetNicePriority();
    // native 方法创建进程
    int pid = nativeForkAndSpecialize(
              uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,
              fdsToIgnore, instructionSet, appDataDir);
    // Enable tracing as soon as possible for the child process.
    ...
    VM_HOOKS.postForkCommon();
    return pid;
}
</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>至此， 我们大致了解了 zygote 是什么以及它的作用</p>
<ul>
<li>Zygote 是由 init 进程，通过执行脚本命令创建的一个进程，由 ZygoteInit main 方法完成初始化</li>
<li>初始化时 启动一个 ZygoteServer，SocketServer 的Java包装类，监听 Socket 连接</li>
<li>ZygoteServer 拿到 Socket 连接 ZygoteConnection(连接的包装类)，处理命令</li>
<li>ZygoteConnection 主要是处理创建进程的命令，最后会回到 Zygote 类 forkAndSpecialize</li>
<li>Zygote.forkAndSpecialize 调用 JNI native 方法实现进程的创建</li>
</ul>
<h2 id="App-的启动"><a href="#App-的启动" class="headerlink" title="App 的启动"></a>App 的启动</h2><p>理解了 Zygote 的作用后，我们以 Android O 源码为基础，分析 Android App 启动的流程，这有助于后续学习 Android framework ，<br>hook技术， dex等知识的学习</p>
<h3 id="Launcher-里启动-App"><a href="#Launcher-里启动-App" class="headerlink" title="Launcher 里启动 App"></a>Launcher 里启动 App</h3><p>在 Launcher 源码里启动 App，调用的也是我们常用的 startActivity 方法。Activity 里的最后调用的是，</p>
<pre><code>public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,
        @Nullable Bundle options) {
    // mParent 指当前的 Activity 是否是嵌套在其他的 Activity 中，我们通常很少嵌套 Activity
    if (mParent == null) {
        // options 参数处理
        options = transferSpringboardActivityOptions(options);
        // 通过 Instrumentation 启动Activity
        // mMainThread.getApplicationThread()返回的是 ApplicationThread，继承自 IApplicationThread.Stub
        Instrumentation.ActivityResult ar =
            mInstrumentation.execStartActivity(
                this, mMainThread.getApplicationThread(), mToken, this,
                intent, requestCode, options);
        if (ar != null) {
            // 发送启动结果
            mMainThread.sendActivityResult(
                mToken, mEmbeddedID, requestCode, ar.getResultCode(),
                ar.getResultData());
        }
        ...
    }
    ...
}
</code></pre><p>Instrumentation 里 execStartActivity，关键的代码在 ActivityManager.getService().startActivity(…) 启动 Activity</p>
<pre><code>public ActivityResult execStartActivity(
    Context who, IBinder contextThread, IBinder token, String target,
    Intent intent, int requestCode, Bundle options) {
    ...
    // ActivityManager.getService 拿到 IActivityManager 调用 startActivity
    int result = ActivityManager.getService()
        .startActivity(whoThread, who.getBasePackageName(), intent,
                intent.resolveTypeIfNeeded(who.getContentResolver()),
                token, target, requestCode, 0, null, options);
    checkStartActivityResult(result, intent);
    ...
}
</code></pre><p>ActivityManager.getService 返回的是 IActivityManager，命名方式可以看出是一个接口</p>
<pre><code>public static IActivityManager getService() {
    return IActivityManagerSingleton.get();
}
</code></pre><p>IActivityManagerSingleton 的初始化，</p>
<pre><code>private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =
    new Singleton&lt;IActivityManager&gt;() {
        @Override
        protected IActivityManager create() {
            // 通过 ServiceManager 拿到 ActivityManagerService(AMS) 的 Service IBinder对象
            final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);
            // IActivityManager.Stub.asInterface 
            final IActivityManager am = IActivityManager.Stub.asInterface(b);
            return am;
        }
    };
</code></pre><p>看到 IActivityManager.Stub.asInterface 是不是有点似曾相似的感觉，是的，这里使用到的就是 AIDL 跨进程通信的机制， IActivityManager 是定义好的 AIDL 接口。Application 层的源码到这里就结束了，再往下，我们就要找 ServiceManager 了</p>
<h3 id="framework-里启动"><a href="#framework-里启动" class="headerlink" title="framework 里启动"></a>framework 里启动</h3><h4 id="Binder-调用AMS"><a href="#Binder-调用AMS" class="headerlink" title="Binder 调用AMS"></a>Binder 调用AMS</h4><p>ServiceManager 在 android.os 包下，看看相关方法</p>
<pre><code>public final class ServiceManager {
    private static final String TAG = &quot;ServiceManager&quot;;
    private static IServiceManager sServiceManager;
    // 定义 HashMap 缓存各种 IBinder 实例，我们的 AMS 实例也是存储在该 hashmap 中
    private static HashMap&lt;String, IBinder&gt; sCache = new HashMap&lt;String, IBinder&gt;();

    private static IServiceManager getIServiceManager() {
        ...
        // ServiceManagerNative 将 Binder 转换为 IServiceManager
        sServiceManager = ServiceManagerNative
                .asInterface(Binder.allowBlocking(BinderInternal.getContextObject()));
        return sServiceManager;
    }

    public static IBinder getService(String name) {
        ...
        // 调用 IServiceManager 的 getService 方法
        return Binder.allowBlocking(getIServiceManager().getService(name));
        ...
    }
}
</code></pre><p>其中 BinderInternal.getContextObject() 是一个 native 方法，返回一个系统全局的 “context” 对象 IBinder，通常是 IServiceManager 的实现。<br>因为是 native 方法，我们可以猜到这个 IServiceManager 实现是由 C++ 来完成的。 这部分就复杂了，感觉越讲内容越多了，不是我们应用启动的内容暂时就到<br>这里。</p>
<p>回到 ServiceManager.getService(“activity”)， 拿到的是 IActivityManager 的实现，AMS 在 com.android.server.am 包下。 调用的是<br>startActivityAsUser() ，这里又使用了 ActivityStarter 来启动</p>
<pre><code>public class ActivityManagerService extends IActivityManager.Stub
    implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {

    @Override
    public final int startActivityAsUser(...) {
        enforceNotIsolatedCaller(&quot;startActivity&quot;);
        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),
                userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null);
        // 调用 ActivityStarter 方法启动
        return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,
                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,
                profilerInfo, null, null, bOptions, false, userId, null, &quot;startActivityAsUser&quot;);
    }
}
</code></pre><p>这里面就不一层层介绍了，实在太绕了，归纳如下流程</p>
<pre><code>ActivityStarter.java:
--&gt;startActivityMayWait
    --&gt;startActivityLocked
        --&gt;startActivity
            --&gt;startActivity
                --&gt;startActivityUnchecked(来自ActivityStackSupervisor的方法) 

ActivityStackSupervisor.java:
    --&gt;resumeFocusedStackTopActivityLocked(来自ActivityStack的方法)  
ActivityStack.java:
    --&gt;resumeTopActivityUncheckedLocked
        --&gt;resumeTopActivityInnerLocked
            --&gt;startSpecificActivityLocked(来自ActivityStackSupervisor)
                --&gt;startProcessLocked(来自AMS,启动新进程)
</code></pre><p>startSpecificActivityLocked 这个方法，检查应用进程记录是否已经运行，</p>
<ul>
<li>如果App 进程记录已经存在，则执行 realStartActivityLocked</li>
<li><p>如果不存在则运行 mService.startProcessLocked</p>
<p>  void startSpecificActivityLocked(ActivityRecord r,</p>
<pre><code>    boolean andResume, boolean checkConfig) {
// 当前 Activity 的 application 是否在运行?
ProcessRecord app = mService.getProcessRecordLocked(r.processName,
        r.info.applicationInfo.uid, true);

r.getStack().setLaunchTime(r);
//app 正在运行，
if (app != null &amp;&amp; app.thread != null) {
    try {
        if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0
                || !&quot;android&quot;.equals(r.info.packageName)) {
            app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,
                    mService.mProcessStats);
        }
        // 1. 执行 realStartActivityLocked
        realStartActivityLocked(r, app, andResume, checkConfig);
        return;
    } catch (RemoteException e) {
        Slog.w(TAG, &quot;Exception when starting activity &quot;
                + r.intent.getComponent().flattenToShortString(), e);
    }
}
// 2. app 未启动， 执行 startProcessLocked，启动新进程
mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,
        &quot;activity&quot;, r.intent.getComponent(), false, false, true);
</code></pre><p>  }</p>
</li>
</ul>
<h4 id="zygote-fork进程启动app"><a href="#zygote-fork进程启动app" class="headerlink" title="zygote fork进程启动app"></a>zygote fork进程启动app</h4><p>由上面的分析，我们知道，在 app 尚未启动时，会执行 mService.startProcessLocked 这个方法</p>
<pre><code>final ProcessRecord startProcessLocked(...) {
    return startProcessLocked(...);
}

final ProcessRecord startProcessLocked(...) {
    long startTime = SystemClock.elapsedRealtime();
    ProcessRecord app;
    // 一系列检查操作
    ...

    // 开始创建进程，同时记录耗时时间
    checkTime(startTime, &quot;startProcess: stepping in to startProcess&quot;);
    startProcessLocked(
            app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);
    checkTime(startTime, &quot;startProcess: done starting proc!&quot;);
    return (app.pid != 0) ? app : null;
}
</code></pre><p>startProcessLocked 里， <strong>这里稍微留一下，entryPoint 被赋值为 android.app.ActivityThread</strong></p>
<pre><code>private final void startProcessLocked(ProcessRecord app, String hostingType,
    String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
    ...
    // Start the process.  It will either succeed and return a result containing
    // the PID of the new process, or else throw a RuntimeException.
    boolean isActivityProcess = (entryPoint == null);
    if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;;
    ...
    if (hostingType.equals(&quot;webview_service&quot;)) {
        ...
    } else {
        // 这里就是开始创建进程的地方了
        startResult = Process.start(entryPoint,
                app.processName, uid, uid, gids, debugFlags, mountExternal,
                app.info.targetSdkVersion, seInfo, requiredAbi, instructionSet,
                app.info.dataDir, invokeWith, entryPointArgs);
    }
    ...
</code></pre><p>来看看 Process 类里是怎么做的，方法也是一堆参数，先忽略了。 可以看到用到了 zygoteProcess 这个类</p>
<pre><code>public static final ZygoteProcess zygoteProcess =
        new ZygoteProcess(&quot;zygote&quot;, &quot;zygote_secondary&quot;);

 public static final ProcessStartResult start(...) {
    return zygoteProcess.start(...);
}
</code></pre><p>简单看看 ZygoteProcess 的构造，可以发现跟 Socket 貌似有点关联，前面了解过 Zygote，我们大概能知道，<br>这里准备要涉及 Socket 来实现进程间的通讯</p>
<pre><code>public class ZygoteProcess {
    /**
    * socket的名称，用于跟主zygote的交流
    */
    private final String mSocket;
    /**
    * 另外一个 zogote socket名称(适配不同 ABI)
    */
    private final String mSecondarySocket;

    public ZygoteProcess(String primarySocket, String secondarySocket) {
        mSocket = primarySocket;
        mSecondarySocket = secondarySocket;
    }

    public final Process.ProcessStartResult start(...) {
        // 通过 Zygote 来启动
        return startViaZygote(processClass, niceName, uid, gid, gids,
                debugFlags, mountExternal, targetSdkVersion, seInfo,
                abi, instructionSet, appDataDir, invokeWith, zygoteArgs);
    }
    ...
}
</code></pre><p>startViaZygote， </p>
<pre><code>/**
* 启动一个新的进程，通过 zygote 机制. 
*/
private Process.ProcessStartResult startViaZygote(...)
                                                  throws ZygoteStartFailedEx {
    // zygote 参数集合                                                          
    ArrayList&lt;String&gt; argsForZygote = new ArrayList&lt;String&gt;();

    // --runtime-args, --setuid=, --setgid=,
    // and --setgroups= must go first
    argsForZygote.add(&quot;--runtime-args&quot;);
    argsForZygote.add(&quot;--setuid=&quot; + uid);
    argsForZygote.add(&quot;--setgid=&quot; + gid);
    if ((debugFlags &amp; Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) {
        argsForZygote.add(&quot;--enable-jni-logging&quot;);
    }
    // 省略的这部分都是往参数集合里加配置参数
    ...
    // 这里 processClass 是 AMS 里的 entryPoint
    argsForZygote.add(processClass);

    synchronized(mLock) {
        // 将参数集合传递
        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);
    }
}
</code></pre><p>主要做了如下操作</p>
<ol>
<li>添加配置参数</li>
<li>openZygoteSocketIfNeeded socket连接操作</li>
<li>zygoteSendArgsAndGetResult 通过 socket 连接发送数据</li>
</ol>
<p>简单看看 zygoteSendArgsAndGetResult，</p>
<pre><code>private static Process.ProcessStartResult zygoteSendArgsAndGetResult(
        ZygoteState zygoteState, ArrayList&lt;String&gt; args)
        throws ZygoteStartFailedEx {
    ...
    // IO 写操作
    final BufferedWriter writer = zygoteState.writer;
    final DataInputStream inputStream = zygoteState.inputStream;

    writer.write(Integer.toString(args.size()));
    writer.newLine();

    for (int i = 0; i &lt; sz; i++) {
        String arg = args.get(i);
        writer.write(arg);
        writer.newLine();
    }
    // 通过 ZygoteState.writer 写数据
    writer.flush();

    // 到这里，进程已经创建完成了，后续就是读取进程 pid 了
    Process.ProcessStartResult result = new Process.ProcessStartResult();

    result.pid = inputStream.readInt();
    result.usingWrapper = inputStream.readBoolean();

    if (result.pid &lt; 0) {
        throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);
    }
    return result;
}
</code></pre><p>了解过 zygote 机制的我们知道，IO 操作，数据会传递给 ZygoteServer 服务端轮询处理，而数据的处理在 ZygoteConnection.processOneCommand，最终通过 Zygote 调用 native 方法 fork 出新的进程</p>
<h3 id="App-进程已存在"><a href="#App-进程已存在" class="headerlink" title="App 进程已存在"></a>App 进程已存在</h3><p>在App 的 Application已经在运行的情况下，会执行 ActivityStackSupervisor 的 realStartActivityLocked 方法</p>
<pre><code>final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,
    boolean andResume, boolean checkConfig) throws RemoteException {
        ...
        app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,
                    System.identityHashCode(r), r.info,
                    mergedConfiguration.getGlobalConfiguration(),
                    mergedConfiguration.getOverrideConfiguration(), r.compat,
                    r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,
                    r.persistentState, results, newIntents, !andResume,
                    mService.isNextTransitionForward(), profilerInfo);
        ...
}
</code></pre><p>scheduleLaunchActivity 是来自 ActivityThread， 最终会使用 Handler 机制，发送 Message 消息去启动Activity</p>
<pre><code>public final void scheduleLaunchActivity(...) {

        updateProcessState(procState, false);

        ActivityClientRecord r = new ActivityClientRecord();
        ...

        sendMessage(H.LAUNCH_ACTIVITY, r);
}
</code></pre><p>handleMessage 处理 LAUNCH_ACTIVITY 消息，</p>
<pre><code>public void handleMessage(Message msg) {
        if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));
        switch (msg.what) {
            case LAUNCH_ACTIVITY: {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);
                final ActivityClientRecord r = (ActivityClientRecord) msg.obj;

                r.packageInfo = getPackageInfoNoCheck(
                        r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            } 
            break;
        }
}
</code></pre><p>handlerLaunchActivity 里的调用 performLaunchActivity 完成最终的启动</p>
<pre><code>private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
    // 构建 component
    ...

    ContextImpl appContext = createBaseContextForActivity(r);
    Activity activity = null;
    try {
        // 通过 ClassLoader 加载 Activity 类，启动
        java.lang.ClassLoader cl = appContext.getClassLoader();
        activity = mInstrumentation.newActivity(
                cl, component.getClassName(), r.intent);
        StrictMode.incrementExpectedActivityCount(activity.getClass());
        r.intent.setExtrasClassLoader(cl);
        r.intent.prepareToEnterProcess();
        if (r.state != null) {
            r.state.setClassLoader(cl);
        }
    } catch (Exception e) {
        ...
    }

    try {
        // 构建 Application
        Application app = r.packageInfo.makeApplication(false, mInstrumentation);

        if (activity != null) {
            ...
            // 调用 Activity attach 到 window
            activity.attach(appContext, this, getInstrumentation(), r.token,
                    r.ident, app, r.intent, r.activityInfo, title, r.parent,
                    r.embeddedID, r.lastNonConfigurationInstances, config,
                    r.referrer, r.voiceInteractor, window, r.configCallback);
            ...
    } catch (SuperNotCalledException e) {
        throw e;
    } catch (Exception e) {

    }
    return activity;
}
</code></pre><p>至此，Activity 的启动页就大致结束了，其他的细节我们就不关注了。<br>此外，这里 ActivityThread 也是我们着重关注的对象.</p>
<h4 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h4><p>ActivityThread 在 Android 中它就代表了 Android 的主线程，但是并不是一个 Thread 类。</p>
<p>严格来说，UI主线程不是 ActivityThread。ActivityThread 类是 Android APP 进程的初始类，它的 main 函数是这个 APP 进程的入口。<br>APP 进程中 UI 事件的执行代码段都是由 ActivityThread 提供的。也就是说，MainThread 实例是存在的，可以理解为 ActivityThread main方法所运行的线程。</p>
<pre><code>public final class ActivityThread {
    ...
    private static ActivityThread sCurrentActivityThread;
    final H mH = new H();

    private void attach(boolean system) {
        sCurrentActivityThread = this;
        ...
    }

    public static void main(String[] args) {
        ...

        // 创建 Looper 和 MessageQueue 对象，用于处理主线程的消息
        Looper.prepareMainLooper();

        // 创建ActivityThread对象
        ActivityThread thread = new ActivityThread(); 

        // 建立Binder通道 (创建新线程)
        thread.attach(false);

        if (sMainThreadHandler == null) {
            // sMainThreadHandler 即 mH
            sMainThreadHandler = thread.getHandler();
        }
        // 消息循环运行
        Looper.loop(); 
        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
    }

    private class H extends Handler {
        public static final int LAUNCH_ACTIVITY         = 100;
        public static final int PAUSE_ACTIVITY          = 101;
        public static final int PAUSE_ACTIVITY_FINISHING= 102;
        public static final int STOP_ACTIVITY_SHOW      = 103;
        public static final int STOP_ACTIVITY_HIDE      = 104;
        public static final int SHOW_WINDOW             = 105;
        public static final int HIDE_WINDOW             = 106;
        public static final int RESUME_ACTIVITY         = 107;
        public static final int SEND_RESULT             = 108;
        public static final int DESTROY_ACTIVITY        = 109;
        public static final int BIND_APPLICATION        = 110;
        public static final int EXIT_APPLICATION        = 111;
        public static final int NEW_INTENT              = 112;
        public static final int RECEIVER                = 113;
        public static final int CREATE_SERVICE          = 114;
        public static final int SERVICE_ARGS            = 115;
        public static final int STOP_SERVICE            = 116;
        ...
    }
}
</code></pre><p>mH Handler 里处理了四大组件的各种消息，如启动 Activity LAUNCH_ACTIVITY，创建Servie CREATE_SERVICE 等等。 可以说 ActivityThread 是 Activity 生命周期中一个至关重要的管理类， 也可以理解为是主线程操作的管理类。   </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大致的流程图如下</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1779563-242eb8b8d0813c17..jpg?imageMogr2/auto-orient/strip|imageView2/2/w/960/format/webp" alt="App启动"></p>
<ol>
<li>点击桌面App图标,Launcher进程采用Binder IPC 向 system_server 进程发起startActivity请求</li>
<li>system_server进程接收到请求后,向zygote进程发送创建进程的请求</li>
<li>Zygote进程fork出新的子进程,即App进程</li>
<li>App进程,通过Binder IPC向sytem_server进程发起attachApplication请求</li>
<li>system_server进程在收到请求后，进行一系列准备工作后,再通过binder IPC向App进程发送scheduleLaunchActivity请求</li>
<li>App进程的binder线程（ApplicationThread）在收到请求后,通过handler向主线程发送LAUNCH_ACTIVITY消息<br>主线程在收到Message后，通过发射机制创建目标Activity,并回调Activity.onCreate()等方法</li>
<li>App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面</li>
</ol>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="pickerX WeChat Pay">
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="pickerX Alipay">
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/framework/" rel="tag"># framework</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/15/android/RxJava-线程调度/" rel="next" title="RxJava-线程调度">
                <i class="fa fa-chevron-left"></i> RxJava-线程调度
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/10/14/ffmpeg/ffmpeg-work-flow/" rel="prev" title="ffmpeg介绍">
                ffmpeg介绍 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">pickerX</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Zygote？"><span class="nav-number">1.</span> <span class="nav-text">Zygote？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Zygote-的运行"><span class="nav-number">1.1.</span> <span class="nav-text">Zygote 的运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化-Zygote"><span class="nav-number">1.2.</span> <span class="nav-text">初始化 Zygote</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZygoteServer-轮询连接"><span class="nav-number">1.3.</span> <span class="nav-text">ZygoteServer 轮询连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZygoteConnection-处理命令"><span class="nav-number">1.4.</span> <span class="nav-text">ZygoteConnection 处理命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">1.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#App-的启动"><span class="nav-number">2.</span> <span class="nav-text">App 的启动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Launcher-里启动-App"><span class="nav-number">2.1.</span> <span class="nav-text">Launcher 里启动 App</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#framework-里启动"><span class="nav-number">2.2.</span> <span class="nav-text">framework 里启动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Binder-调用AMS"><span class="nav-number">2.2.1.</span> <span class="nav-text">Binder 调用AMS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#zygote-fork进程启动app"><span class="nav-number">2.2.2.</span> <span class="nav-text">zygote fork进程启动app</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#App-进程已存在"><span class="nav-number">2.3.</span> <span class="nav-text">App 进程已存在</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ActivityThread"><span class="nav-number">2.3.1.</span> <span class="nav-text">ActivityThread</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pickerX</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
