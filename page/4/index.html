<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hello,world">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Hello,world">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hello,world">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/">





  <title>Hello,world</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hello,world</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/21/java/并发编程-Queues/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ticooops">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello,world">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/21/java/并发编程-Queues/" itemprop="url">并发编程--Queues</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-21T14:46:53+08:00">
                2018-02-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列我们会分为两种，并发阻塞队列和并发不阻塞队列. 阻塞队列常用的有</p>
<pre><code>ArrayBlockingQueue
LinkedBlockingQueue
PriorityBlockingQueue
SynchronousQueue
DelayQueue
</code></pre><p>非阻塞队列常用的有</p>
<pre><code>ConcurrentLinkedQueue
ConcurrentLinkedDeque
</code></pre><p>这些类涵盖了开发时大多数的用法，如生产者-消费者，消息传送，并发任务以及其他并发的设计<br>实现接口 TransferQueue，并继承 LinkedTransferQueue， 重写同步方法 transfer 也可以达到阻塞消费者的效果</p>
<h3 id="并发阻塞队列-BlockingQueue"><a href="#并发阻塞队列-BlockingQueue" class="headerlink" title="并发阻塞队列 BlockingQueue"></a>并发阻塞队列 BlockingQueue</h3><p>java.util.concurrent 包里的 BlockingQueue 接口表示一个线程添加和提取实例的队列。 BlockingQueue 提供了4组不同的操作来实现 insert, remove, examine。</p>
<table>
<thead>
<tr>
<th></th>
<th>抛异常</th>
<th>特殊值</th>
<th>阻塞</th>
<th>超时</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>删除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td>检查</td>
<td>element()</td>
<td>peak()</td>
<td>NONE</td>
<td>NONE</td>
</tr>
</tbody>
</table>
<ul>
<li>抛异常：如果试图的操作无法立即执行，抛一个异常。</li>
<li>特定值：如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。</li>
<li>阻塞：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。</li>
<li>超时：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。</li>
</ul>
<p>此外，BlockingQueue 接口有以下几个特点:</p>
<ul>
<li>BlockingQueue 不接受 Null 对象, add，put，offfer 等操作Null对象会抛出异常</li>
<li>BlockingQueue 有大小的限制，</li>
<li>BlockingQueue 是线程安全的</li>
<li>BlockingQueue 被设计为主要用于生产者，消费者队列，但也支持Collection接口。不过remove(x)这样的操作是低效率的，建议少用</li>
<li>BlockingQueue 没有类似 close，shutdown的操作去禁止添加新对象，类似的功能需要子类去实现</li>
</ul>
<h4 id="ArrayBlockingQueue-数组阻塞队列"><a href="#ArrayBlockingQueue-数组阻塞队列" class="headerlink" title="ArrayBlockingQueue 数组阻塞队列"></a>ArrayBlockingQueue 数组阻塞队列</h4><p>ArrayBlockingQueue 是一个有界的阻塞队列，其内部实现是将对象放到一个数组里。有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了(译者注：因为它是基于数组实现的，也就具有数组的特性：一旦初始化，大小就无法修改)。</p>
<p><strong>Simple Usage</strong></p>
<pre><code>BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue(1024);  
queue.put(&quot;1&quot;);
Object object = queue.take();
</code></pre><p>LinkedBlockingQueue<br>PriorityBlockingQueue</p>
<h4 id="DelayQueue延迟队列"><a href="#DelayQueue延迟队列" class="headerlink" title="DelayQueue延迟队列"></a>DelayQueue延迟队列</h4><p>DelayQueue 实现了 BlockingQueue 接口。DelayQueue 对元素进行持有直到一个特定的延迟到期。注入其中的元素必须实现 java.util.concurrent.Delayed 接口，该接口定义：</p>
<pre><code>public interface Delayed extends Comparable&lt;Delayed&lt; {  
    public long getDelay(TimeUnit timeUnit); 

    public int compareTo(@NonNull Delayed o);
}
</code></pre><p>DelayQueue 将会在每个元素的 getDelay() 方法返回的值的时间段之后才释放掉该元素。如果返回的是 0 或者负值，延迟将被认为过期，该元素将会在 DelayQueue 的下一次 take 被调用的时候被释放掉。传递给 getDelay 方法的 timeUnit 实例是一个枚举类型，它表明了将要延迟的时间段。</p>
<h4 id="LinkedBlockingQueue-链阻塞队列"><a href="#LinkedBlockingQueue-链阻塞队列" class="headerlink" title="LinkedBlockingQueue 链阻塞队列"></a>LinkedBlockingQueue 链阻塞队列</h4><p>LinkedBlockingQueue 类实现了 BlockingQueue 接口。<br>LinkedBlockingQueue 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。<br>LinkedBlockingQueue 内部以 FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。</p>
<h4 id="PriorityBlockingQueue-优先级的阻塞队列"><a href="#PriorityBlockingQueue-优先级的阻塞队列" class="headerlink" title="PriorityBlockingQueue 优先级的阻塞队列"></a>PriorityBlockingQueue 优先级的阻塞队列</h4><p>PriorityBlockingQueue 类实现了 BlockingQueue 接口。</p>
<p>PriorityBlockingQueue 是一个无界的并发队列。它使用了和类 java.util.PriorityQueue 一样的排序规则。你无法向这个队列中插入 null 值。所有插入到 PriorityBlockingQueue 的元素必须实现 java.lang.Comparable 接口。因此该队列中元素的排序就取决于你自己的 Comparable 实现。注意 PriorityBlockingQueue 对于具有相等优先级(compare() == 0)的元素并不强制任何特定行为。</p>
<p>同时注意，如果你从一个 PriorityBlockingQueue 获得一个 Iterator 的话，该 Iterator 并不能保证它对元素的遍历是以优先级为序的。</p>
<h4 id="SynchronousQueue-同步队列"><a href="#SynchronousQueue-同步队列" class="headerlink" title="SynchronousQueue 同步队列"></a>SynchronousQueue 同步队列</h4><p>SynchronousQueue 类实现了 BlockingQueue 接口。</p>
<p>SynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。<br>据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。</p>
<h3 id="阻塞双端队列-BlockingDeque"><a href="#阻塞双端队列-BlockingDeque" class="headerlink" title="阻塞双端队列 BlockingDeque"></a>阻塞双端队列 BlockingDeque</h3><p>java.util.concurrent 包里的 BlockingDeque 接口表示一个线程安放入和提取实例的双端队列。本小节我将给你演示如何使用 BlockingDeque。BlockingDeque 类是一个双端队列，在不能够插入元素时，它将阻塞住试图插入元素的线程；在不能够抽取元素时，它将阻塞住试图抽取的线程。deque(双端队列) 是 “Double Ended Queue” 的缩写。因此，双端队列是一个你可以从任意一端插入或者抽取元素的队列。</p>
<p><img src="http://incdn1.b0.upaiyun.com/2017/09/7fd6edb69f79e90d2b3f1c1f9f7decb4.png" alt="BlockingDeque"></p>
<p>一个线程生产元素，并把它们插入到队列的任意一端。如果双端队列已满，插入线程将被阻塞，直到一个移除线程从该队列中移出了一个元素。如果双端队列为空，移除线程将被阻塞，直到一个插入线程向该队列插入了一个新元素。</p>
<h4 id="BlockingDeque-的方法"><a href="#BlockingDeque-的方法" class="headerlink" title="BlockingDeque 的方法"></a>BlockingDeque 的方法</h4><p>BlockingDeque 具有 4 组不同的方法用于插入、移除以及对双端队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下：<br><img src="http://incdn1.b0.upaiyun.com/2017/09/d672dc8aa890b81604b8fe31f3b513ef.png" alt="method"><br>四组不同的行为方式解释：</p>
<ul>
<li>抛异常：如果试图的操作无法立即执行，抛一个异常。</li>
<li>特定值：如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。</li>
<li>阻塞：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。</li>
<li>超时：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。</li>
</ul>
<p><strong>Simple Usage</strong><br>既然 BlockingDeque 是一个接口，它的实现类有：LinkedBlockingDeque，ConcurrentLinkedDeque</p>
<pre><code>BlockingDeque&lt;String&gt; deque = new LinkedBlockingDeque&lt;String&gt;();  

deque.addFirst(&quot;1&quot;);  
deque.addLast(&quot;2&quot;);  

String two = deque.takeLast();  
String one = deque.takeFirst();
</code></pre><h3 id="Concurrent队列"><a href="#Concurrent队列" class="headerlink" title="Concurrent队列"></a>Concurrent队列</h3><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p>一个没有大小限制，线程安全，使用链式结构设计的非阻塞式队列。 ConcurrentLinkedQueue也是使用FIFO的设计理念， 同其他并发队列一样，该队列也不允许元素是Null对象。使用的算法是Maged M. Michael and Michael L. Scott.设计出来的<a href="http://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf" target="_blank" rel="noopener"> Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms </a></p>
<p>请注意，与大多数集合不同， size方法不是总是准确的。由于这些队列的异步性质，如果当前线程需要遍历元素，而其他线程在遍历期间修改此集合，则可能会返回不准确的size结果。此外，该批量操作addAll，removeAll，retainAll， containsAll，equals和toArray 不能保证是按原子执行的。<br>内存一致性效果：与其他并发集合一样，在将对象放入 ConcurrentLinkedQueue happen-before 在另一个线程中从 ConcurrentLinkedQueue 访问或删除该元素。<br>补充：<a href="http://www.importnew.com/28263.html" target="_blank" rel="noopener">HashMap 和 ConcurrentHashMap 全解析</a></p>
<h4 id="ConcurrentLinkedDeque"><a href="#ConcurrentLinkedDeque" class="headerlink" title="ConcurrentLinkedDeque"></a>ConcurrentLinkedDeque</h4><p>同ConcurrentLinkedQueue， 额外实现了Deque接口支持双向操作<br>参考: <a href="http://www.importnew.com/26461.html" target="_blank" rel="noopener">importnew</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/15/java/并发编程-内存模型/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ticooops">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello,world">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/15/java/并发编程-内存模型/" itemprop="url">Java内存模型深度解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-15T09:17:08+08:00">
                2018-02-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>内存模型的系列文章，请参考，有一种恍然大悟的感觉</p>
<ul>
<li><a href="http://www.codeceo.com/article/java-memory-1.html#comments" target="_blank" rel="noopener">Java内存模型深度解析：基础部分</a></li>
<li><a href="http://www.codeceo.com/article/java-memeory-2.html" target="_blank" rel="noopener">Java内存模型深度解析：重排序</a></li>
<li><a href="http://www.codeceo.com/article/java-memory-3.html" target="_blank" rel="noopener">Java内存模型深度解析：顺序一致性</a></li>
<li><a href="http://www.codeceo.com/article/java-memory-4.html" target="_blank" rel="noopener">Java内存模型深度解析：volatile</a> </li>
<li><a href="http://www.codeceo.com/article/java-memory-5.html" target="_blank" rel="noopener">Java内存模型深度解析：锁</a></li>
<li><a href="http://www.codeceo.com/article/java-memory-6.html" target="_blank" rel="noopener">Java内存模型深度解析：final</a></li>
<li><a href="http://www.codeceo.com/article/java-memory-7.html" target="_blank" rel="noopener">Java内存模型深度解析：总结</a></li>
</ul>
<p>其中, 对volatile的补充 ==&gt; <a href="https://liuzhengyang.github.io/2017/03/28/volatileandlock/" target="_blank" rel="noopener">volatile和lock原理分析</a><br>对多线程的补充 ==&gt; <a href="https://www.iteye.com/topic/806990" target="_blank" rel="noopener">java线程安全总结</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现如今，处理器使用写缓冲区来临时保存向内存写入的数据。 但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会以及处理器重排序对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，<strong>不一定与内存实际发生的读/写操作顺序一致。</strong><br>除了顺序一致性外(有序性)，并发编程我们还会遇到一个可见性的问题：多个线程之间是不能互相传递数据通信的，它们之间的沟通只能通过共享变量来进行，如果一个线程修改了共享变量，其他线程并不能马上看到这个被修改后的数值。<br>为了保证顺序一致性和可见性，我们会有几种方式来处理，</p>
<ul>
<li>线程通信<ul>
<li>共享内存</li>
<li>消息传递</li>
</ul>
</li>
<li>线程同步</li>
</ul>
<h3 id="线程同步的几种方式"><a href="#线程同步的几种方式" class="headerlink" title="线程同步的几种方式"></a>线程同步的几种方式</h3><h4 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h4><p>修饰方法</p>
<pre><code>public synchronized void method() {
    ...
}
</code></pre><p>修饰代码块</p>
<pre><code>synchronized(object){ 
    ...
}
</code></pre><p>同步是一种高开销的操作，因此应该尽量减少同步的内容。<br>通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可</p>
<h4 id="特殊域变量-volatile"><a href="#特殊域变量-volatile" class="headerlink" title="特殊域变量 volatile"></a>特殊域变量 volatile</h4><p>多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。<br>用final域，有锁保护的域和volatile域可以避免非同步的问题。 </p>
<pre><code>class Bank {
    //需要同步的变量加上volatile
    private volatile int account = 100;

    public int getAccount() {
        return account;
    }
    //这里不再需要synchronized 
    public void save(int money) {
        account += money;
    }
｝
</code></pre><ol>
<li>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li>
<li>volatile 可以禁止指令重排，这就保证了代码的程序会严格按照代码的先后顺序执行</li>
<li>volatile 是不能保证原子性的</li>
<li>volatile 没有涉及到锁操作，比使用同步的开销更低</li>
</ol>
<p>volatile 是适合读多写少的场景。当只有一个线程可以修改字段的值，其它线程可以随时读取，那么把字段声明为volatile是合理的</p>
<h4 id="阻塞队列实现线程同步"><a href="#阻塞队列实现线程同步" class="headerlink" title="阻塞队列实现线程同步"></a>阻塞队列实现线程同步</h4><p>并发编程-Queues 一篇里已经介绍过，java.util.concurrent 里为我们提供了很多便利的阻塞队列类，主要实现 BlockingQueue 接口。 通常会使用LinkedBlockingQueue<e> 等来实现同步，常用于生产者-消费者模式下的场景</e></p>
<h4 id="原子变量-atomic"><a href="#原子变量-atomic" class="headerlink" title="原子变量 atomic"></a>原子变量 atomic</h4><p>需要使用线程同步的根本原因在于对普通变量的操作不是原子的。<br>那么什么是原子操作呢？<br>原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作，即这几种行为要么同时完成，要么都不完成。  </p>
<p>在Java的 util.concurrent.atomic 包中提供了创建了原子类型变量的工具类，简化线程的同步。其中 AtomicInteger类可以用原子方式更新int的值，可用在应用程序中(如以原子方式增加的计数器)，但不能用于替换Integer；可扩展 Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。</p>
<p>AtomicInteger类常用方法：  </p>
<ul>
<li>AtomicInteger(int initialValue) : 创建具有给定初始值的新的  AtomicInteger  </li>
<li>addAddGet(int dalta) : 以原子方式将给定值与当前值相加  </li>
<li>get() : 获取当前值  </li>
</ul>
<p>原子操作主要有：  </p>
<ul>
<li>引用变量和大多数原始变量(long和double除外)的读写操作；  </li>
<li>所有使用 volatile 修饰的变量(包括long和double)的读写操作。  </li>
</ul>
<p><strong>Simple Usage</strong></p>
<pre><code>class Bank {
    private AtomicInteger account = new AtomicInteger(100);

    public AtomicInteger getAccount() {
        return account;
    }

    public void save(int money) {
        account.addAndGet(money);
    }
}
</code></pre><h4 id="局部变量-ThreadLocal"><a href="#局部变量-ThreadLocal" class="headerlink" title="局部变量 ThreadLocal"></a>局部变量 ThreadLocal</h4><p>如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，<br>副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。  </p>
<pre><code>ThreadLocal 类的常用方法  
ThreadLocal() : 创建一个线程本地变量   
get() : 返回此线程局部变量的当前线程副本中的值   
initialValue() : 返回此线程局部变量的当前线程的&quot;初始值&quot;   
set(T value) : 将此线程局部变量的当前线程副本中的值设置为value  
</code></pre><p><strong>Simple Usage</strong>  </p>
<pre><code>public class Bank {
    //使用ThreadLocal类管理共享变量account
    private static ThreadLocal&lt;Integer&gt; account = new ThreadLocal&lt;Integer&gt;() {
        @Override
        protected Integer initialValue() {
            return 100;
        }
    };

    public void save(int money) {
        account.set(account.get() + money);
    }

    public int getAccount() {
        return account.get();
    }
}
</code></pre><p>注：ThreadLocal 与同步机制   </p>
<ul>
<li>ThreadLocal 与同步机制都是为了解决多线程中相同变量的访问冲突问题。  </li>
<li>前者采用以”空间换时间”的方法，后者采用以”时间换空间”的方式  </li>
</ul>
<h4 id="重入锁-Lock"><a href="#重入锁-Lock" class="headerlink" title="重入锁 Lock"></a>重入锁 Lock</h4><p>在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁， 它与使用 synchronized 方法和代码块具有相同的基本行为和语义，并且扩展了其能力，更灵活，二者性能上差不多</p>
<pre><code>class Bank { 
    private int account = 100;
    //需要声明这个锁
    private Lock lock = new ReentrantLock();

    public int getAccount() {
        return account;
    }

    //这里不再需要synchronized 
    public void save(int money) {
        lock.lock();
        try {
            account += money;
        } finally {
            lock.unlock();
        }

    }
｝
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/10/java/并发编程-Tools/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ticooops">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello,world">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/10/java/并发编程-Tools/" itemprop="url">并发编程-工具类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-10T19:01:19+08:00">
                2018-02-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>常用于并发处理的集合Queues，ConcurrentHashMap，ConcurrentSkipListMap<br>，ConcurrentSkipListSet，CopyOnWriteArrayList，CopyOnWriteArraySet， 这些集合都比较好理解和使用，不多bb。本文介绍一些比较难接触的并发处理类</p>
<h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><a href="https://developer.android.google.cn/reference/java/util/concurrent/Semaphore" target="_blank" rel="noopener">Semaphore</a></h4><p>信号量，一个经典的并发工具，常用于限制访问资源的线程数量。<br>通常我们会使用synchronized和Lock锁实现资源并发访问的控制，在同一时间只允许一个线程进入临界区访问资源(读锁除外)，解决多个线程并发同一资源造成的数据不一致问题。Semaphore使用场景略有不同，在一个共享的资源里，有多个(有限个)副本可以使用的情况下，如果并发的线程超过可使用的副本时，我们就可以使用Semaphore来控制资源副本访问的线程数。</p>
<p><strong>实现原理</strong><br>Semaphore保护一个或多个共享资源的使用，内部维护了一个计数器，即同一时间最多的可访问线程数。<br>一个线程要访问资源时，需要先获取Semaphore， 如果Semaphore的计数器大于1，表示可以使用该资源，Semaphore.acquire()之后，计数器减1，访问该资源，使用完后，Semaphore.release()释放信号量，计数器加1，其他被阻塞的线程会被唤醒获取信号量，访问资源。 如果计数器为0，线程进入休眠.</p>
<p><strong>Sample usage</strong>  </p>
<pre><code>class Pool {
    private static final int MAX_AVAILABLE = 100;
    private final Semaphore available = new Semaphore(MAX_AVAILABLE, true);

    public Object getItem() throws InterruptedException {
        available.acquire();
        return getNextAvailableItem();
    }

    public void putItem(Object x) {
        if (markAsUnused(x))
        available.release();
    }

    // Not a particularly efficient data structure; just for demo

    protected Object[] items = ... whatever kinds of items being managed
    protected boolean[] used = new boolean[MAX_AVAILABLE];

    protected synchronized Object getNextAvailableItem() {
        for (int i = 0; i &lt; MAX_AVAILABLE; ++i) {
            if (!used[i]) {
                used[i] = true;
                return items[i];
            }
        }
        return null; // not reached
    }

    protected synchronized boolean markAsUnused(Object item) {
        for (int i = 0; i &lt; MAX_AVAILABLE; ++i) {
            if (item == items[i]) {
                if (used[i]) {
                    used[i] = false;
                    return true;
                } else
                    return false;
            }
        }
        return false;
    }
}
</code></pre><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><a href="https://developer.android.google.cn/reference/java/util/concurrent/CountDownLatch" target="_blank" rel="noopener">CountDownLatch</a></h4><p>使一个线程等待其他线程完成各自的工作后再执行.例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。</p>
<p><strong>实现原理</strong><br>是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。  </p>
<p><img src="http://incdn1.b0.upaiyun.com/2015/04/f65cc83b7b4664916fad5d1398a36005.png" alt="CountDownLatch"></p>
<p>CountDownLatch构造器</p>
<pre><code>//Constructs a CountDownLatch initialized with the given count.
public void CountDownLatch(int count) {...}
</code></pre><p>构造器中的计数值（count）实际上就是闭锁需要等待的线程数量。这个值只能被设置一次，而且CountDownLatch没有提供任何机制去重新设置这个计数值。<br>与CountDownLatch的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用CountDownLatch.await()方法，这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p>
<p>其他N个线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务。这种通知机制是通过 CountDownLatch.countDown()方法来完成的；每调用一次这个方法，在构造函数中初始化的count值就减1。所以当N个线程都调 用了这个方法，count的值等于0，然后主线程就能通过await()方法，恢复执行自己的任务。</p>
<p><strong>Sample usage1</strong></p>
<p>子线程等待主线程完成准备工作，子线程才执行  </p>
<pre><code>class Driver { // ...
    void main() throws InterruptedException {
        CountDownLatch startSignal = new CountDownLatch(1);
        CountDownLatch doneSignal = new CountDownLatch(N);
        // create and start threads
        for (int i = 0; i &lt; N; ++i) 
            new Thread(new Worker(startSignal, doneSignal)).start();

        doSomethingElse();            // don&apos;t let run yet
        startSignal.countDown();      // let all threads proceed
        doSomethingElse();
        // 阻塞主线程，等待其他线程完成
        doneSignal.await();           // wait for all to finish
    }
}

class Worker implements Runnable {
    private final CountDownLatch startSignal;
    private final CountDownLatch doneSignal;
    Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {
        this.startSignal = startSignal;
        this.doneSignal = doneSignal;
    }
    public void run() {
        try {
            // 阻塞线程
            startSignal.await();
            doWork();
            doneSignal.countDown();
        } catch (InterruptedException ex) {} // return;
    }

    void doWork() { ... }
}
</code></pre><p><strong>Sample usage2</strong></p>
<p>主线程等待子线程完成工作，才执行</p>
<pre><code>class Driver2 { // ...
    void main() throws InterruptedException {
        CountDownLatch doneSignal = new CountDownLatch(N);
        Executor e = ...

        for (int i = 0; i &lt; N; ++i) // create and start threads
        e.execute(new WorkerRunnable(doneSignal, i));

        doneSignal.await();           // wait for all to finish
    }
}

class WorkerRunnable implements Runnable {
    private final CountDownLatch doneSignal;
    private final int i;
    WorkerRunnable(CountDownLatch doneSignal, int i) {
        this.doneSignal = doneSignal;
        this.i = i;
    }
    public void run() {
        try {
            doWork(i);
            doneSignal.countDown();
        } catch (InterruptedException ex) {} // return;
    }

    void doWork() { ... }
}  
</code></pre><p>CountDownLatch面试题:  </p>
<p>解释一下CountDownLatch概念?<br>CountDownLatch 和CyclicBarrier的不同之处?<br>给出一些CountDownLatch使用的例子?<br>CountDownLatch 类中主要的方法?  </p>
<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a><a href="https://developer.android.google.cn/reference/java/util/concurrent/CyclicBarrier" target="_blank" rel="noopener">CyclicBarrier</a></h4><p>是一个同步工具类，它允许一组线程互相等待，直到到达某个公共屏障点，与CountDownLatch不同的是该barrier在释放等待线程后可以重用。 CyclicBarrier支持一个可选的Runnable命令，在一组线程中的最后一个线程到达之后（但在释放所有线程之前），该命令只在每个屏障点运行一次。若在继续所有参与线程之前更新共享状态，此屏障操作很有用。    </p>
<p>CyclicBarrier的一些关键方法</p>
<pre><code>public CyclicBarrier(int parties, Runnable barrierAction)
public CyclicBarrier(int parties)

// 返回值为当前线程的索引，0表示当前线程是最后一个到达的线程
public int await() throws InterruptedException, BrokenBarrierException

//在await()的基础上增加超时机制，如果超出指定的等待时间，则抛出 //TimeoutException 异常。如果该时间小于等于零，则此方法根本不会等待。
public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException
</code></pre><p><strong>Sample Usage</strong>  </p>
<p>每个Worker处理矩阵中的一行，在处理完所有的行之前，该线程将一直在屏障处等待。在各个Worker处理完所有行后，将执行提供的Runnable屏障操作。</p>
<pre><code>public class Solver {
    final int N;
    final float[][] data;
    final CyclicBarrier barrier;

    public Solver(float[][] matrix) throws InterruptedException {
        data = matrix;
        N = matrix.length;
        Runnable barrierAction =
                () -&gt; {
                    System.out.println(&quot;finish row process&quot;);
                };
        barrier = new CyclicBarrier(N, barrierAction);

        List&lt;Thread&gt; threads = new ArrayList&lt;&gt;(N);
        for (int i = 0; i &lt; N; i++) {
            Thread thread = new Thread(new Worker(i));
            threads.add(thread);
            thread.start();
        }
        // System.out.println(&quot;wait until done...&quot;);
        // wait until done
        for (Thread thread : threads) {
            thread.join();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        float[][] matrix = new float[][]{
                new float[]{1, 2, 3, 4, 5},
                new float[]{6, 7, 8, 9, 10},
                new float[]{11, 12, 13, 14, 15},
                new float[]{16, 17, 18, 19, 20},
                new float[]{21, 22, 23, 24, 25},
        };
        Solver solver = new Solver(matrix);
    }

    class Worker implements Runnable {
        int myRow;
        boolean isDone = false;

        Worker(int row) {
            myRow = row;
        }

        public void run() {
            while (!done()) {
                isDone = processRow(myRow);
                try {
                    System.out.println(&quot;barrier await:&quot; + barrier.getNumberWaiting());
                    barrier.await();
                } catch (InterruptedException | BrokenBarrierException ex) {
                    return;
                }
            }
        }

        private boolean done() {
            return isDone;
        }

        private boolean processRow(int myRow) {
            final int rows = data.length;
            for (int i = 0; i &lt; rows; i++) {
                if (i == myRow) {
                    System.out.println(&quot;========&gt;process myRow:&quot; + myRow);
                    float[] row = data[myRow];
                    for (float v : row) {
                        System.out.println(&quot;process value:&quot; + v);
                    }
                    return true;
                }
            }
            return false;
        }
    }
}
</code></pre><h4 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a><a href="https://developer.android.google.cn/reference/java/util/concurrent/Phaser" target="_blank" rel="noopener">Phaser</a></h4><p>一个可重复使用的同步屏障，功能类似于CyclicBarrier和CountDownLatch，但支持更灵活的使用。</p>
<p><strong>原理</strong>  </p>
<p><strong>Sample usages</strong><br>Phaser可以代替CountDownLatch来构建一个服务于多个对象只执行一次的行动。这个典型的应用惯例是注册–&gt;执行任务–&gt;撤销，例如：</p>
<pre><code>void runTasks(List&lt;Runnable&gt; tasks) {
    final Phaser phaser = new Phaser(1); // &quot;1&quot; to register self
    // create and start threads
    for (final Runnable task : tasks) {
        phaser.register();
        new Thread() {
            public void run() {
                phaser.arriveAndAwaitAdvance(); // await all creation
                task.run();
            }
        }.start();
    }
    // allow threads to start and deregister self
    phaser.arriveAndDeregister();
}
</code></pre><p>可以通过覆盖onAdvance来实现让多个线程把某些任务执行固定的次数。</p>
<pre><code>void startTasks(List&lt;Runnable&gt; tasks, final int iterations) {
    final Phaser phaser = new Phaser() {
        protected boolean onAdvance(int phase, int registeredParties) {
            return phase &gt;= iterations || registeredParties == 0;
        }
    };
    phaser.register();
    for (final Runnable task : tasks) {
        phaser.register();
        new Thread() {
            public void run() {
                do {
                    task.run();
                    phaser.arriveAndAwaitAdvance();
                } while (!phaser.isTerminated());
            }
        }.start();
    }
    phaser.arriveAndDeregister(); // deregister self, don&apos;t wait
}
</code></pre><p>如果主任务需要等待phaser的结束，那么它可以不断地注册自己从而执行一个类似循环：</p>
<pre><code>// ...
phaser.register();
while (!phaser.isTerminated())
    phaser.arriveAndAwaitAdvance();
</code></pre><p>你可以等待特定的不超过Integer.MAX_VALUE的阶段数。例如：</p>
<pre><code>void awaitPhase(Phaser phaser, int phase) {
    int p = phaser.register(); // assumes caller not already registered
    while (p &lt; phase) {
        if (phaser.isTerminated())
        // ... deal with unexpected termination
        else
        p = phaser.arriveAndAwaitAdvance();
    }
    phaser.arriveAndDeregister();
}
</code></pre><p>创建一个集合的任务可以使用一个树结构的phasers，你能够使用以下的代码，假如一个Task类有一个构造函数接受一个Phaser从而进行注册。在调用build(new Task[n], 0, n, new Phaser())后，这些任务能够被执行，<br>比如提交给一个线程池：</p>
<pre><code>void build(Task[] tasks, int lo, int hi, Phaser ph) {
    if (hi - lo &gt; TASKS_PER_PHASER) {
        for (int i = lo; i &lt; hi; i += TASKS_PER_PHASER) {
        int j = Math.min(i + TASKS_PER_PHASER, hi);
        build(tasks, i, j, new Phaser(ph));
        }
    } else {
        for (int i = lo; i &lt; hi; ++i)
        tasks[i] = new Task(ph);
        // assumes new Task(ph) performs ph.register()
    }
}
</code></pre><p>最好的{TASKS_PER_PHASER}依赖于期待的同步速率。很小的数字比如4适合于执行非常小的任务（所以速率高），或者成百上千适合于使用大任务。<br>注意：我们的这个实现将参与者的上限定为65535.尝试注册更多的参与者会导致IllegalStateException异常。当然，你可以通过使用分层Phaser的方法去满足任意数量的参与者。</p>
<h4 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a><a href="https://developer.android.google.cn/reference/java/util/concurrent/Exchanger" target="_blank" rel="noopener">Exchanger</a></h4><p>一般用于两个工作线程之间交换数据，在一些pipeline设计上非常有用.<br>Exchanger有几个特征：  </p>
<ol>
<li>此类提供对外的操作是同步的；</li>
<li>用于成对出现的线程之间交换数据；</li>
<li>可以视作双向的同步队列；</li>
<li>可应用于基因算法、流水线设计等场景。</li>
</ol>
<p><strong>实现原理</strong>  </p>
<p>当一个线程到达exchange调用点时，如果它的伙伴线程此前已经调用了此方法，那么它的伙伴会被调度唤醒并与之进行对象交换，然后各自返回。如果它的伙伴还没到达交换点，那么当前线程将会被挂起，直至伙伴线程到达，依次完成交换正常返回；或者当前线程被中断——抛出中断异常；又或者是等候超时——抛出超时异常。</p>
<p><strong>Sample Usage</strong>  </p>
<pre><code>class FillAndEmpty {
    Exchanger&lt;DataBuffer&gt; exchanger = new Exchanger&lt;&gt;();
    DataBuffer initialEmptyBuffer = ... a made-up type
    DataBuffer initialFullBuffer = ...

    class FillingLoop implements Runnable {
        public void run() {
            DataBuffer currentBuffer = initialEmptyBuffer;
            try {
                while (currentBuffer != null) {
                    addToBuffer(currentBuffer);
                    if (currentBuffer.isFull())
                        currentBuffer = exchanger.exchange(currentBuffer);
                    }
            } catch (InterruptedException ex) { 
                ... handle ... 
            }
        }
    }

    class EmptyingLoop implements Runnable {
        public void run() {
            DataBuffer currentBuffer = initialFullBuffer;
            try {
                while (currentBuffer != null) {
                    takeFromBuffer(currentBuffer);
                    if (currentBuffer.isEmpty())
                        currentBuffer = exchanger.exchange(currentBuffer);
                }
            } catch (InterruptedException ex) { ... handle ...}
        }
    }

    void start() {
        new Thread(new FillingLoop()).start();
        new Thread(new EmptyingLoop()).start();
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/09/java/Java集合/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ticooops">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello,world">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/09/java/Java集合/" itemprop="url">Java集合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-09T10:00:40+08:00">
                2018-02-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合框架的设计目标：  </p>
<ol>
<li>该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。  </li>
<li>该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li>
<li>对一个集合的扩展和适应必须是简单的。  </li>
</ol>
<p>为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList, HashSet, 和 TreeSet 等,除此之外你也可以通过这些接口实现自己的集合。  </p>
<h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><p><img src="http://www.runoob.com/wp-content/uploads/2014/01/2243690-9cd9c896e0d512ed.gif" alt="集合框架"><br><br>其中，集合里一些注意点</p>
<ol>
<li>Collection List采用线性列表的存储方式，长度可动态改变， Map采用键值对的存储方式，长度也能动态改变</li>
<li>Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。</li>
<li>Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有HashSet,TreeSet&gt;。</li>
<li>List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt; 。</li>
</ol>
<h3 id="线程安全的集合等工具"><a href="#线程安全的集合等工具" class="headerlink" title="线程安全的集合等工具"></a>线程安全的集合等工具</h3><p>上面常用的集合都有一个特点，它们都不是线程安全的，Vector, HashTable 除外。<br>Java针对线程安全，重新设计了与通用集合相同接口的一组集合。通常线程安全相关的类都会封装在java.util.concurrent 包里。虽然开发中我们经常使用线程，但真正用好的并不多，遇到多线程的问题时，往往会不知所措，找不到原因，所以我们有必要把这一块吃透。该文章先介绍线程安全的工具，后续再开篇幅介绍多线程.  </p>
<p>concurrent 并发相关的包主要有三个，</p>
<pre><code>java.util.concurrent
java.util.concurrent.locks
java.util.concurrent.atomic
</code></pre><p>java.util.concurrent 下包含以下几大模块</p>
<ol>
<li>Executors<ul>
<li>Interfaces Executor是一个用来自定义具有线程功能的标准化接口，比如线程池，异步IO，轻量级任务架构</li>
<li>Implementations 实现类如ThreadPoolExecutor，ScheduledThreadPoolExecutor， ForkJoinPool等等</li>
</ul>
</li>
<li>Queues <ul>
<li>ConcurrentLinkedQueue提供了一个高效，灵活的，非阻塞的线程安全队列</li>
<li>ConcurrentLinkedDeque同ConcurrentLinkedQueue类似，额外实现了Deque接口, 提供了双向添加，删除对象的能力</li>
</ul>
</li>
<li>Timing<br>TimeUnit, 时间工具，控制线程的执行时刻，周期等</li>
<li>Synchronizers<br>五个处理并发线程的工具类<ul>
<li><a href="https://developer.android.google.cn/reference/java/util/concurrent/Semaphore" target="_blank" rel="noopener">Semaphore</a> 信号量，一个经典的并发工具，常用于限制访问资源的线程数量</li>
<li><a href="https://developer.android.google.cn/reference/java/util/concurrent/CountDownLatch" target="_blank" rel="noopener">CountDownLatch</a> 简单易用的倒计时工具类，常用于阻塞其他线程对资源的访问</li>
<li><a href="https://developer.android.google.cn/reference/java/util/concurrent/CyclicBarrier" target="_blank" rel="noopener">CyclicBarrier</a>在一些并发的开发中，CyclicBarrier是一个让多线程相互阻塞直到某一个Barrier点的，可复用的工具类</li>
<li><a href="https://developer.android.google.cn/reference/java/util/concurrent/Phaser" target="_blank" rel="noopener">Phaser</a>提供一个更灵活的工具用于控制多线程的执行阶段</li>
<li><a href="https://developer.android.google.cn/reference/java/util/concurrent/Exchanger" target="_blank" rel="noopener">Exchanger</a>运行两个线程相互交换数据在指定的点上，在一些pipeline设计上非常有用.  </li>
</ul>
</li>
<li>Concurrent Collections<br>除了 Queues 外，Concurrent 包还提供了用于多线程的集合 <ul>
<li>ConcurrentHashMap 替换HashMap的线程安全集合</li>
<li>ConcurrentSkipListMap 替换TreeMap的线程安全集合</li>
<li>ConcurrentSkipListSet </li>
<li>CopyOnWriteArrayList  替换ArrayList的线程安全集合</li>
<li>CopyOnWriteArraySet   并发优化的ArrayList。基于不可变对象策略，在修改时先复制出一个数组快照来修改，改好了，再让内部指针指向新数组。</li>
</ul>
</li>
</ol>
<h3 id="Memory-Consistency-Properties"><a href="#Memory-Consistency-Properties" class="headerlink" title="Memory Consistency Properties"></a>Memory Consistency Properties</h3><pre><code>内存一致性[Chapter 17 of The Java™ Language Specification](https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5)定义了在内存操作的happens-before关系，比如对共享对象的读写操作。  
一个线程写操作的结果要被另一个线程查看到，写的操作必须 happens-before读的操作。synchronized，volatile关键字，Thread.start()， Thread.join()方法，常用于实现happens-before的关系。特别地，
1. Each action in a thread happens-before every action in that thread that comes later in the program&apos;s order.
2. An unlock (synchronized block or method exit) of a monitor happens-before every subsequent lock (synchronized block or method entry) of that same monitor. And because the happens-before relation is transitive, all actions of a thread prior to unlocking happen-before all actions subsequent to any thread locking that monitor.
3. A write to a volatile field happens-before every subsequent read of that same field. Writes and reads of volatile fields have similar memory consistency effects as entering and exiting monitors, but do not entail mutual exclusion locking.
4. A call to start on a thread happens-before any action in the started thread.
5. All actions in a thread happen-before any other thread successfully returns from a join on that thread.
</code></pre><p>补充:<a href="http://www.cnblogs.com/CarpenterLee/p/5545987.html" target="_blank" rel="noopener">《深入理解Java集合框架》系列文章</a></p>
<p>参考内容：<br><a href="https://developer.android.google.cn/reference/java/util/concurrent/package-summary" target="_blank" rel="noopener">Android API</a><br><a href="https://docs.oracle.com/javase/8/docs/api/index.html" target="_blank" rel="noopener">Java API</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/09/java/Java排序算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ticooops">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello,world">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/09/java/Java排序算法/" itemprop="url">Java排序算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-09T07:55:13+08:00">
                2018-02-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>相关引用: <a href="https://www.jianshu.com/p/8c915179fd02" target="_blank" rel="noopener">八种常见排序算法</a></p>
<h3 id="常用查找算法的Java实现-转"><a href="#常用查找算法的Java实现-转" class="headerlink" title="常用查找算法的Java实现(转)"></a>常用查找算法的Java实现(转)</h3><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><pre><code>/**顺序查找平均时间复杂度 O（n） 
* @param searchKey 要查找的值 
* @param array 数组（从这个数组中查找） 
* @return  查找结果（数组的下标位置） 
*/  
public static int orderSearch(int searchKey,int[] array){  
    if(array==null||array.length&lt;1)  
        return -1;  
    for(int i=0;i&lt;array.length;i++){  
        if(array[i]==searchKey){  
            return i;  
        }  
    }  
    return -1;          
}  
</code></pre><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><pre><code>/** 
* 二分查找又称折半查找，它是一种效率较高的查找方法。 【二分查找要求】：1.必须采用顺序存储结构 2.必须按关键字大小有序排列。 
*  
* @param array 
*            有序数组 * 
* @param searchKey 
*            查找元素 * 
* @return searchKey的数组下标，没找到返回-1 
*/  
public static int binarySearch(int[] array, int searchKey) {  
    int low = 0;  
    int high = array.length - 1;  
    while (low &lt;= high) {  
        int middle = (low + high) / 2;  
        if (searchKey == array[middle]) {  
            return middle;  
        } else if (searchKey &lt; array[middle]) {  
            high = middle - 1;  
        } else {  
            low = middle + 1;  
        }  
    }  
    return -1;  
}  
</code></pre><h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><p>a. 首先将查找表分成若干块，在每一块中数据元素的存放是任意的，但块与块之间必须是有序的（假设这种排序是按关键字值递增的，也就是说在第一块中任意一个数据元素的关键字都小于第二块中所有数据元素的关键字，第二块中任意一个数据元素的关键字都小于第三块中所有数据元素的关键字，依次类推）；<br>b. 建立一个索引表，把每块中最大的关键字值按块的顺序存放在一个辅助数组中，这个索引表也按升序排列；<br>c. 查找时先用给定的关键字值在索引表中查找，确定满足条件的数据元素存放在哪个块中，查找方法既可以是折半方法，也可以是顺序查找。<br>d. 再到相应的块中顺序查找，便可以得到查找的结果。 </p>
<pre><code>/** 
* 分块查找 
*  
* @param index 
*            索引表，其中放的是各块的最大值 
* @param st 
*            顺序表， 
* @param key 
*            要查找的值 
* @param m 
*            顺序表中各块的长度相等，为m 
* @return 
*/  
public static int blockSearch(int[] index, int[] st, int key, int m) {  
    // 在序列st数组中，用分块查找方法查找关键字为key的记录  
    // 1.在index[ ] 中折半查找，确定要查找的key属于哪个块中  
    int i = binarySearch(index, key);  
    if (i &gt;= 0) {  
        int j = i &gt; 0 ? i * m : i;  
        int len = (i + 1) * m;  
        // 在确定的块中用顺序查找方法查找key  
        for (int k = j; k &lt; len; k++) {  
            if (key == st[k]) {  
                System.out.println(&quot;查询成功&quot;);  
                return k;  
            }  
        }  
    }  
    System.out.println(&quot;查找失败&quot;);  
    return -1;  
}  
</code></pre><h4 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h4><p>哈希表查找是通过对记录的关键字值进行运算，直接求出结点的地址，是关键字到地址的直接转换方法，不用反复比较。假设f包含n个结点，Ri为其中某个结点（1≤i≤n），keyi是其关键字值，在keyi与Ri的地址之间建立某种函数关系，可以通过这个函数把关键字值转换成相应结点的地址，有：addr(Ri)=H(keyi)，addr(Ri)为哈希函数。<br>解决冲突的方法有以下两种：　　<br>(1)开放地址法　　<br>如果两个数据元素的哈希值相同，则在哈希表中为后插入的数据元素另外选择一个表项。当程序查找哈希表时，如果没有在第一个对应的哈希表项中找到符合查找要求的数据元素，程序就会继续往后查找，直到找到一个符合查找要求的数据元素，或者遇到一个空的表项。　　<br>(2)链地址法<br>将哈希值相同的数据元素存放在一个链表中，在查找哈希表的过程中，当查找到这个链表时，必须采用线性查找方法。   </p>
<pre><code>/**** 
* Hash查找 
*  
* @param hash 
* @param hashLength 
* @param key 
* @return 
*/  
public static int searchHash(int[] hash, int hashLength, int key) {  
    // 哈希函数  
    int hashAddress = key % hashLength;  

    // 指定hashAdrress对应值存在但不是关键值，则用开放寻址法解决  
    while (hash[hashAddress] != 0 &amp;&amp; hash[hashAddress] != key) {  
        hashAddress = (++hashAddress) % hashLength;  
    }  

    // 查找到了开放单元，表示查找失败  
    if (hash[hashAddress] == 0)  
        return -1;  
    return hashAddress;  

}  

/*** 
* 数据插入Hash表 
*  
* @param hash 
*            哈希表 
* @param hashLength 
* @param data 
*/  
public static void insertHash(int[] hash, int hashLength, int data) {  
    // 哈希函数  
    int hashAddress = data % hashLength;  

    // 如果key存在，则说明已经被别人占用，此时必须解决冲突  
    while (hash[hashAddress] != 0) {  
        // 用开放寻址法找到  
        hashAddress = (++hashAddress) % hashLength;  
    }  

    // 将data存入字典中  
    hash[hashAddress] = data;  
}  
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/08/java/类与接口/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ticooops">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello,world">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/08/java/类与接口/" itemprop="url">类与接口</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-08T09:28:16+08:00">
                2018-02-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类是一个模板，描述一类对象的行为和状态</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>为其子类提供一个公共的类型，封装子类中具有相同属性的内容，定义抽象方法，子类虽然有不同的实现 但是定义是一致的</p>
<h3 id="内部类的作用"><a href="#内部类的作用" class="headerlink" title="内部类的作用"></a>内部类的作用</h3><ol>
<li>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li>
<li>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。</li>
<li>创建内部类对象的时刻并不依赖于外围类对象的创建。</li>
<li>内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</li>
<li>内部类提供了更好的封装，除了该外围类，其他类都不能访问</li>
</ol>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>首先，接口并不是类，它们属于不同的概念， 接口是Java中一种抽象类型，通常包含一系列抽象方法的集合。<br>接口的意义：规范、扩展、回调</p>
<h3 id="抽象类与接口区别"><a href="#抽象类与接口区别" class="headerlink" title="抽象类与接口区别"></a>抽象类与接口区别</h3><ol>
<li>默认的方法实现<br>抽象类可以有默认的方法实现，类依然可以是抽象的。<br>接口可以使用default关键字实现默认方法而不要求其子类进行实现</li>
<li>实现<br>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。<br>子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现</li>
<li>构造器<br>抽象类可以有构造器<br>接口不能有构造器</li>
<li>与正常Java类的区别<br>除了你不能实例化抽象类之外，它和普通Java类没有任何区别；<br>接口是完全不同的类型</li>
<li>访问修饰符<br>抽象方法可以有public、protected和default这些修饰符；<br>接口方法默认修饰符是public。你不可以使用其它修饰符。</li>
<li>main方法<br>抽象方法可以有main方法并且我们可以运行它；<br>接口没有main方法，因此我们不能运行它。</li>
<li>多继承<br>抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。</li>
<li>速度<br>类比接口速度要快<br>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</li>
<li>添加新方法<br>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。<br>如果你往接口中添加方法，那么你必须改变实现该接口的类。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/08/java/Java面向对象的理解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ticooops">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello,world">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/08/java/Java面向对象的理解/" itemprop="url">Java面向对象的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-08T09:11:25+08:00">
                2018-02-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java-三大特性"><a href="#Java-三大特性" class="headerlink" title="Java 三大特性"></a>Java 三大特性</h2><p>封装，继承，多态</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保存在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。<br>封装有几个好处</p>
<pre><code>1. 良好的封装能够减少耦合。
2. 类内部的结构可以自由修改。
3. 隐藏信息，实现细节。
</code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>Definitions: A class that is derived from another class is called a subclass (also a derived class, extended class, or child class). The class from which the subclass is derived is called a superclass (also a base class or a parent class). 通过使用继承我们能够非常方便地复用以前的代码，还能对类进行扩展, 能够大大的提高开发的效率。但是有几点缺陷:</p>
<pre><code>1. 父类变，子类就必须变。
2. 继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。
3. 继承是一种强耦合关系。
</code></pre><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>定义: 所谓多态就是指程序中定义的引用变量所指向的具体类型，以及该引用变量调用的方法在编译期间是不确定的，而是在程序运行时才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量调用的方法到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因此, 多态具有以下两个特点:</p>
<pre><code>1. 指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的；  
2. 若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）
</code></pre><p>优点：</p>
<ol>
<li>减少重复代码，使代码变得简洁,可维护。</li>
<li>提高代码扩展性。 新增子类不影响已存在类的多态性，子类也很容易就能扩展新功能</li>
<li>在创建对象的时候，结合工厂模式，当需要不同的子类实现时，只需在工厂类里修改即可，不用关心具体创建的是什么对象</li>
</ol>
<p>实现方式: 继承和接口。<br>多态存在的三个必要条件</p>
<ol>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ticooops</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ticooops</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
