<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Android,RxJava,">










<meta name="description" content="RxJava &amp;amp; RxAndroid关于RxJava的使用和基本框架,网上有很多资源就不重复造轮子了, 汇总了如下干货:    扔物线大佬的 给Android开发者的RxJava详解 RxJava2操作符汇总 操作符flatMap 与 concatMap详解  掌握上面的知识面试上基本没啥问题, 本文会着重解说RxJava里的线程操作, 学习线程的用法 RxJava线程以最简单的Rx操作符">
<meta name="keywords" content="Android,RxJava">
<meta property="og:type" content="article">
<meta property="og:title" content="RxJava线程是如何控制的(上)">
<meta property="og:url" content="http://yoursite.com/2018/03/14/android/RxJava线程是如何控制的-1/index.html">
<meta property="og:site_name" content="Hello,world">
<meta property="og:description" content="RxJava &amp;amp; RxAndroid关于RxJava的使用和基本框架,网上有很多资源就不重复造轮子了, 汇总了如下干货:    扔物线大佬的 给Android开发者的RxJava详解 RxJava2操作符汇总 操作符flatMap 与 concatMap详解  掌握上面的知识面试上基本没啥问题, 本文会着重解说RxJava里的线程操作, 学习线程的用法 RxJava线程以最简单的Rx操作符">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-01-18T11:21:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RxJava线程是如何控制的(上)">
<meta name="twitter:description" content="RxJava &amp;amp; RxAndroid关于RxJava的使用和基本框架,网上有很多资源就不重复造轮子了, 汇总了如下干货:    扔物线大佬的 给Android开发者的RxJava详解 RxJava2操作符汇总 操作符flatMap 与 concatMap详解  掌握上面的知识面试上基本没啥问题, 本文会着重解说RxJava里的线程操作, 学习线程的用法 RxJava线程以最简单的Rx操作符">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/03/14/android/RxJava线程是如何控制的-1/">





  <title>RxJava线程是如何控制的(上) | Hello,world</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hello,world</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/14/android/RxJava线程是如何控制的-1/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="pickerX">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello,world">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">RxJava线程是如何控制的(上)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-14T10:42:33+08:00">
                2018-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="RxJava-amp-RxAndroid"><a href="#RxJava-amp-RxAndroid" class="headerlink" title="RxJava &amp; RxAndroid"></a>RxJava &amp; RxAndroid</h3><p>关于RxJava的使用和基本框架,网上有很多资源就不重复造轮子了, 汇总了如下干货:  </p>
<ol>
<li>扔物线大佬的 <a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给Android开发者的RxJava详解</a></li>
<li><a href="https://www.jianshu.com/p/f54f32b39b7c" target="_blank" rel="noopener">RxJava2操作符汇总</a></li>
<li><a href="https://www.jianshu.com/p/f67e05d7cd30" target="_blank" rel="noopener">操作符flatMap 与 concatMap详解</a></li>
</ol>
<p>掌握上面的知识面试上基本没啥问题, 本文会着重解说RxJava里的线程操作, 学习线程的用法</p>
<h3 id="RxJava线程"><a href="#RxJava线程" class="headerlink" title="RxJava线程"></a>RxJava线程</h3><p>以最简单的Rx操作符为例, </p>
<pre><code>Observable.just(&quot;value&quot;)
                .subscribeOn(Schedulers.newThread())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(e -&gt; {}, 
                    e -&gt; { e.printStackTrace(); },
                    ()-&gt;{}));
</code></pre><p>不管多么复杂的操作符, 关于线程操作的始终只有两个地方, subscribeOn和observeOn. 分别来看看他们的实现()的实现，</p>
<h3 id="subscribeOn-amp-observeOn流程分析"><a href="#subscribeOn-amp-observeOn流程分析" class="headerlink" title="subscribeOn &amp; observeOn流程分析"></a>subscribeOn &amp; observeOn流程分析</h3><p>subscribeOn源码</p>
<pre><code>Observable.java
/**
    * Asynchronously subscribes Observers to this ObservableSource on the specified {@link Scheduler}.
    * @param scheduler
    *            the {@link Scheduler} to perform subscription actions on
    * @return the source ObservableSource modified so that its subscriptions happen on the
    *         specified {@link Scheduler}
    */
@CheckReturnValue
@SchedulerSupport(SchedulerSupport.CUSTOM)
public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) {
    ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);
    return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));
}
</code></pre><p>通过注释可以知道，指定Scheduler，异步地将Observers subscribe到ObservableSource. RxJavaPlugins是一个工具类, 包含很多便利的静态方法.<br>先来看 RxJavaPlugins.onAssembly， 这里有个hook方法 f，onObservableAssembly默认是null，所以这里并不会做什么操作直接返回source. 如果 onObservableAssembly 不为null，则会调用该 hook 方法, 实现 T t –&gt; 泛型R的转换</p>
<pre><code>RxJavaPlugins.java
/**
 * Calls the associated hook function.
 * @param &lt;T&gt; the value type
 * @param source the hook&apos;s input value
 * @return the value returned by the hook
 */
@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
@NonNull
public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) {
    Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly;
    if (f != null) {
        return apply(f, source);
    }
    return source;
}

@NonNull
static &lt;T, R&gt; R apply(@NonNull Function&lt;T, R&gt; f, @NonNull T t) {
    try {
        return f.apply(t);
    } catch (Throwable ex) {
        throw ExceptionHelper.wrapOrThrow(ex);
    }
}
</code></pre><p>所以在subscribeOn里, 创建并返回了一个新对象 ObservableSubscribeOn . ObservableSubscribeOn 类的代码不多, ObservableSubscribeOn的构造方法参数source 就是我们使用just操作符创建的对象ObservableJust. ObservableSubscribeOn 中只有一个可执行方法 subscribeActual. 作用如注释</p>
<pre><code>public final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; {
    final Scheduler scheduler;

    public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) {
        super(source);
        this.scheduler = scheduler;
    }

    @Override
    public void subscribeActual(final Observer&lt;? super T&gt; s) {
        // 1.创建了 SubscribeOnObserver 实例
        final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s);
        // 2.Observer执行onSubscribe, 传递parent参数,用于取消Disposable
        s.onSubscribe(parent);
        // 3.parent调用setDisposable, 
        parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));
    }
}
</code></pre><p>第三步中, scheduler.scheduleDirect 创建一个SubscribeTask并执行任务，返回一个Disposable. scheduleDirect 里面比较复杂, 我们先来看看 SubscribeOnObserver 这个类是干嘛用的. 源码如下:  </p>
<pre><code>static final class SubscribeOnObserver&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements Observer&lt;T&gt;, Disposable {

    private static final long serialVersionUID = 8094547886072529208L;
    final Observer&lt;? super T&gt; actual;

    final AtomicReference&lt;Disposable&gt; s;

    SubscribeOnObserver(Observer&lt;? super T&gt; actual) {
        this.actual = actual;
        this.s = new AtomicReference&lt;Disposable&gt;();
    }

    @Override
    public void onSubscribe(Disposable s) {
        DisposableHelper.setOnce(this.s, s);
    }

    @Override
    public void onNext(T t) {
        actual.onNext(t);
    }

    @Override
    public void onError(Throwable t) {
        actual.onError(t);
    }

    @Override
    public void onComplete() {
        actual.onComplete();
    }

    @Override
    public void dispose() {
        DisposableHelper.dispose(s);
        DisposableHelper.dispose(this);
    }

    @Override
    public boolean isDisposed() {
        return DisposableHelper.isDisposed(get());
    }

    void setDisposable(Disposable d) {
        DisposableHelper.setOnce(this, d);
    }
}
</code></pre><p>内容也不多, 继承 AtomicReference, 并实现 Observer<t>, Disposable 两个接口, 对Observer进行扩展，起到代理的作用。提供了disposable的能力， 使用 AtomicReference 保证了 SubscribeOnObserver 对象的线程安全。那SubscribeTask又是什么呢？？</t></p>
<pre><code>final class SubscribeTask implements Runnable {
    private final SubscribeOnObserver&lt;T&gt; parent;

    SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) {
        this.parent = parent;
    }

    @Override
    public void run() {
        source.subscribe(parent);
    }
}
</code></pre><p>可以发现，是一个简单的线程，用于执行source的subscribe方法， 这里的source即操作符just创建出来的对象 ObservableJust 。不同的操作符这个source不太一样, 但他们都是Observable的子类，故会执行Observable里的 subscribe方法或者它们重写的subscribe方法。因此在整个过程中 ObservableSubscribeOn 类里与线程相关的核心代码在。 </p>
<pre><code>scheduler.scheduleDirect(new SubscribeTask(parent))
</code></pre><p>我们先不看scheduler里的代码，这里发现一个问题 source.subscribe(parent)<br>这里跟RxJava的最后一个步骤主动调用操作符的 subscribe 方法最终会调用如下的函数，故实际会执行两次的subscribe方法。是不是重复执行了呢？为什么会这样呢？</p>
<pre><code>public final void subscribe(Observer&lt;? super T&gt; observer) {
    ObjectHelper.requireNonNull(observer, &quot;observer is null&quot;);
    try {
        observer = RxJavaPlugins.onSubscribe(this, observer);

        ObjectHelper.requireNonNull(observer, &quot;Plugin returned null Observer&quot;);

        subscribeActual(observer);
    } catch (NullPointerException e) { // NOPMD
        throw e;
    } catch (Throwable e) {
       ...
    }
}
</code></pre><p>在使用RxJava的最后一步，我们会调用如下重载方法 subscribe，最终才调用 subscribe(ls). 而这里的 subscribeActual 并不是调用 ObservableJust 的重写方法，而是 ObservableSubscribeOn(subscribeOn操作创建) 或者 ObservableObserveOn(observeOn操作创建) 的 subscribeActual 方法. 而ObservableSubscribeOn里保存了操作符 ObservableJust source，在subscribeActual 完成了线程的先关操作，采用的是一种责任链的设计模式来达到这种效果.</p>
<pre><code>public final Disposable subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError,
        Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe) {
    ...
    LambdaObserver&lt;T&gt; ls = new LambdaObserver&lt;T&gt;(onNext, onError, onComplete, onSubscribe);
    subscribe(ls);
    return ls;
}

@Override
public void subscribeActual(final Observer&lt;? super T&gt; s) {
    final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s);

    s.onSubscribe(parent);

    parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));
}
</code></pre><p>同理 observeOn 操作，也是在 subscribeActual 里完成线程的处理</p>
<pre><code>protected void subscribeActual(Observer&lt;? super T&gt; observer){
    if (scheduler instanceof TrampolineScheduler) {
        source.subscribe(observer);
    } else {
        Scheduler.Worker w = scheduler.createWorker();

        source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));
    }
}
</code></pre><h3 id="核心线程操作"><a href="#核心线程操作" class="headerlink" title="核心线程操作"></a>核心线程操作</h3><p>理清了代码的执行流程后，回过头来看 ObservableSubscribeOn 里的线程处理， </p>
<p>scheduler.scheduleDirect(new SubscribeTask(parent)));</p>
<p>通过指定的 Scheduler，本例中用的是 Schedulers.newThread()，然后调用 scheduleDirect 方法启动线程, 我们也不妨看看 Schedulers.io, Schedulers.computation, Schedulers.single 分别创建了什么 Scheduler</p>
<pre><code>static final class SingleHolder {
    static final Scheduler DEFAULT = new SingleScheduler();
}

static final class ComputationHolder {
    static final Scheduler DEFAULT = new ComputationScheduler();
}

static final class IoHolder {
    static final Scheduler DEFAULT = new IoScheduler();
}

static final class NewThreadHolder {
    static final Scheduler DEFAULT = new NewThreadScheduler();
}

static {
    SINGLE = RxJavaPlugins.initSingleScheduler(new SingleTask());

    COMPUTATION = RxJavaPlugins.initComputationScheduler(new ComputationTask());

    IO = RxJavaPlugins.initIoScheduler(new IOTask());

    TRAMPOLINE = TrampolineScheduler.instance();

    NEW_THREAD = RxJavaPlugins.initNewThreadScheduler(new NewThreadTask());
}

static final class NewThreadTask implements Callable&lt;Scheduler&gt; {
    @Override
    public Scheduler call() throws Exception {
        return NewThreadHolder.DEFAULT;
    }
}
</code></pre><p>分析可以发现，IO，NEW_THREAD 等静态变量的初始化方式一样，都是用单利模式创建的，因此 Schedulers.single, Schedulers.computation, Schedulers.io, Schedulers.newThread, 分别会创建如下的 Scheduler</p>
<ol>
<li>SingleScheduler  一个共享的，单一线程 Scheduler</li>
<li>ComputationScheduler 持有一个固定工作线程数量的线程池, 通过 round-robin 轮询的方式处理 Scheduler.Workder</li>
<li>IoScheduler  创建并缓存线程，会尽可能的重复使用已存在的线程</li>
<li>NewThreadScheduler 创建新线程的一个调度器</li>
</ol>
<p>NewThreadScheduler 继承 Scheduler，用于调度工作单元。核心的方法是 createWorker， 创建一个 NewThreadWorker，是RxJava线程调度的工作单位。 </p>
<pre><code>public final class NewThreadScheduler extends Scheduler {
    private final ThreadFactory threadFactory;

    public NewThreadScheduler() {
        this(THREAD_FACTORY);
    }

    public NewThreadScheduler(ThreadFactory threadFactory) {
        this.threadFactory = threadFactory;
    }

    @Override
    public Worker createWorker() {
        return new NewThreadWorker(threadFactory);
    }
}
</code></pre><p>Scheduler的创建到这里基本就结束了，回到 ObservableSubscribeOn 执行 scheduleDirect.</p>
<pre><code>@NonNull
public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {
    final Worker w = createWorker();
    final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);
    DisposeTask task = new DisposeTask(decoratedRun, w);
    w.schedule(task, delay, unit);
    return task;
}
</code></pre><p>同时这里还</p>
<ol>
<li>调用 Scheduler(本例即 NewThreadScheduler ) 的 createWorkder 方法，创建工作单元 NewThreadWorker</li>
<li>通过 RxJavaPlugins.onSchedule 封装了我们的Runable(即前文的SubscribeTask) decoratedRun，同之前的一些添加 hook 操作一样，方便扩展，默认不变还是传递的参数 SubscribeTask 实例    </li>
<li>创建 DisposeTask，DisposeTask 也是一个 Runnable，实现了其他接口，扩展了能力</li>
<li>Worker 执行调度 schedule，核心参数 DisposeTask task</li>
</ol>
<p>第4点，DisposeTask 是个 Runnable, 看关键的 run 方法，主要执行了 decoratedRun即 SubscribeTask 实例</p>
<pre><code>static final class DisposeTask implements Disposable, Runnable, SchedulerRunnableIntrospection {

        @NonNull
        final Runnable decoratedRun;
        @NonNull
        final Worker w;
        @Nullable
        Thread runner;

        DisposeTask(@NonNull Runnable decoratedRun, @NonNull Worker w) {
            this.decoratedRun = decoratedRun;
            this.w = w;
        }

        @Override
        public void run() {
            runner = Thread.currentThread();
            try {
                decoratedRun.run();
            } finally {
                dispose();
                runner = null;
            }
        }
}
</code></pre><p>因此，我们的操作符工作最终还是会分配到 NewThreadWorker 上面。 不同的Scheduler，工作单元不太一样，比如 SingleScheduler 用的是 SingleScheduler.ScheduledWorker, 相同的是它们都是继承自 Scheduler.Worker<br>故，这里主要执行了这两个步骤，</p>
<ul>
<li>Scheduler的子类调用createWorker实现， 创建Worker实例，</li>
<li>执行Worker实例</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于篇幅长度限制本文就先到这里了。 通过分析，我们了解了 </p>
<ol>
<li>RxJava subscribeOn的执行流程(observerOn同理)</li>
<li>Schedulers 创建 Scheduler 的类型</li>
<li>RxJava的执行单元  Scheduler.Worker </li>
</ol>
<p>后续将着重介绍RxJava线程的内容，码字不易，纸上得来终觉浅，绝知此事要躬行。</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="pickerX WeChat Pay">
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="pickerX Alipay">
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/RxJava/" rel="tag"># RxJava</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/13/java/HashMap实现原理/" rel="next" title="HashMap实现原理">
                <i class="fa fa-chevron-left"></i> HashMap实现原理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/16/android/RxJava线程是如何控制的-2/" rel="prev" title="RxJava线程是如何控制的(下)">
                RxJava线程是如何控制的(下) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">pickerX</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#RxJava-amp-RxAndroid"><span class="nav-number">1.</span> <span class="nav-text">RxJava &amp; RxAndroid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RxJava线程"><span class="nav-number">2.</span> <span class="nav-text">RxJava线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#subscribeOn-amp-observeOn流程分析"><span class="nav-number">3.</span> <span class="nav-text">subscribeOn &amp; observeOn流程分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#核心线程操作"><span class="nav-number">4.</span> <span class="nav-text">核心线程操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">pickerX</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
